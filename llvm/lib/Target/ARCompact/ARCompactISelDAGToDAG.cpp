//==- ARCompactISelDAGToDAG.cpp - A dag to dag inst selector for ARCompact -==//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the ARCOMPACT target.
//
//===----------------------------------------------------------------------===//

#include "ARCompactTargetMachine.h"
#include "llvm/Intrinsics.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

/// ARCompactDAGToDAGISel - ARCOMPACT specific code to select ARCOMPACT machine
/// instructions for SelectionDAG operations.
namespace {
class ARCompactDAGToDAGISel : public SelectionDAGISel {
  const ARCompactSubtarget &Subtarget;
  ARCompactTargetMachine& TM;
public:
  explicit ARCompactDAGToDAGISel(ARCompactTargetMachine &tm)
      : SelectionDAGISel(tm),
        Subtarget(tm.getSubtarget<ARCompactSubtarget>()),
        TM(tm) {
  }

  // Complex Pattern Selectors.
  // TODO: Merge these into just one or two and select between them in-code.
  bool SelectADDRri(SDValue N, SDValue &Base, SDValue &Offset);
  bool SelectADDRri2(SDValue N, SDValue &Base, SDValue &Offset);
  bool SelectADDRli(SDValue N, SDValue &AddrOut);
  bool SelectADDRrr(SDValue N, SDValue &R1, SDValue &R2);
  bool SelectADDRrli(SDValue N, SDValue &R1, SDValue &Offset);
  bool SelectADDRlir(SDValue N, SDValue &R1, SDValue &Offset);

  virtual const char *getPassName() const {
    return "ARCOMPACT DAG->DAG Pattern Instruction Selection";
  }

  // Include the pieces autogenerated from the target description.
  #include "ARCompactGenDAGISel.inc"

private:
  SDNode *Select(SDNode *N);
};
}  // end anonymous namespace

/// Converts the memory address Addr into a base address Base and an immediate
/// offset Offset, or returns false if unable to process the memory address.
bool ARCompactDAGToDAGISel::SelectADDRri(SDValue Addr, SDValue &Base,
    SDValue &Offset) {
  // If Addr is a frame index, the offset will be computed later, in
  // eliminateFrameIndex.
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
    Offset = CurDAG->getTargetConstant(0, MVT::i32);
    return true;
  }

  // Handle some special cases for the source of the memory address.
  switch (Addr.getOpcode()) {
    case ISD::ADD:
      // If the address is calculated from an addition computation, we may as
      // well absorb the addition into the address.
      if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
        uint64_t CVal = CN->getZExtValue();
        // If shifting left,right 56 bits (64 - 8) doesnt change CVal's value,
        // it is an 9-bit integer. Cannot use 32-bit case as we may have a limm
        // source operand.
        if (((CVal << 56) >> 56) == CVal) {
          SDValue N0 = Addr.getOperand(0);
          if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(N0)) {
            Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
          }
          else {
            Base = N0;
          }

          Offset = CurDAG->getTargetConstant(CVal, MVT::i32);
          return true;
        }
      }
      break;
    case ARCISD::Wrapper:
      // The address is wrapped in a specific ARCompact wrapper, meaning it
      // might be a GlobalAddress, or ??.
      SDValue N0 = Addr.getOperand(0);
      if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(N0)) {
        Base = CurDAG->getTargetGlobalAddress(G->getGlobal(),
            Addr.getDebugLoc(), MVT::i32, G->getOffset());
        Offset = CurDAG->getTargetConstant(0, MVT::i32);

        return true;
      }
      break;
  }

  // Default to an offset of 0 and a Base of Addr.
  Base = Addr;
  Offset = CurDAG->getTargetConstant(0, MVT::i32);
  return true;
}

/// Sets AddrOut to the value of the memory operands address, or
/// return false if unable to process the memory address (e.g. if
/// it is not a limm address).
bool ARCompactDAGToDAGISel::SelectADDRli(SDValue Addr, SDValue &AddrOut) {

  // Handle some special cases for the source of the memory address.
  switch (Addr.getOpcode()) {
    case ARCISD::Wrapper:
      // The address is wrapped in a specific ARCompact wrapper, meaning it
      // might be a GlobalAddress, or ??.
      SDValue N0 = Addr.getOperand(0);
      if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(N0)) {
        AddrOut = CurDAG->getTargetGlobalAddress(G->getGlobal(),
            Addr.getDebugLoc(), MVT::i32, G->getOffset());
        return true;
      }
      break;
  }

  return false;
}

/// Version of SelectADDRri that can't do a global address as the LHS is a LI.
bool ARCompactDAGToDAGISel::SelectADDRri2(SDValue Addr, SDValue &Base,
    SDValue &Offset) {
  // If Addr is a frame index, the offset will be computed later, in
  // eliminateFrameIndex.
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
    Offset = CurDAG->getTargetConstant(0, MVT::i32);
    return true;
  }

  // Handle some special cases for the source of the memory address.
  switch (Addr.getOpcode()) {
    case ISD::ADD:
      // If the address is calculated from an addition computation, we may as
      // well absorb the addition into the address.
      if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
        uint64_t CVal = CN->getZExtValue();
        // If shifting left,right 56 bits (64 - 8) doesnt change CVal's value,
        // it is an 8-bit integer. Cannot use 32-bit case as we may have a limm
        // source operand.
        if (((CVal << 56) >> 56) == CVal) {
          SDValue N0 = Addr.getOperand(0);
          if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(N0)) {
            Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
          }
          else {
            Base = N0;
          }

          Offset = CurDAG->getTargetConstant(CVal, MVT::i32);
          return true;
        }
      }
      break;
    case ARCISD::Wrapper:
      return false;
  }

  // Default to an offset of 0 and a Base of Addr.
  Base = Addr;
  Offset = CurDAG->getTargetConstant(0, MVT::i32);
  return true;
}



/// Sets R1 and R2 to the values of the memory address operands, or
/// return false if unable to process the memory address (e.g. if
/// it is not a register, register address).
bool ARCompactDAGToDAGISel::SelectADDRrr(SDValue Addr, SDValue &R1,
    SDValue &R2) {
  return false;
}

/// Sets R1 and Offset to the values of the memory address operands, or
/// return false if unable to process the memory address (e.g. if
/// it is not a register, long-immediate address).
bool ARCompactDAGToDAGISel::SelectADDRrli(SDValue Addr, SDValue &R1,
    SDValue &Offset) {
  return false;
}

/// Sets Offset and R1 to the values of the memory address operands, or
/// return false if unable to process the memory address (e.g. if
/// it is not a long-immediate, register address).
bool ARCompactDAGToDAGISel::SelectADDRlir(SDValue Addr, SDValue &Offset,
    SDValue &R1) {
  return false;
}

SDNode *ARCompactDAGToDAGISel::Select(SDNode *Op) {
  DebugLoc dl = Op->getDebugLoc();

  if (Op->isMachineOpcode()) {
    // This is an ARCompact instruction - it has already been selected!
    return NULL;
  }

  // Check if we need to do anything extra for the operation.
  switch (Op->getOpcode()) {
    case ISD::FrameIndex: {
      // Frame Indexes have to be converted to an ADDrli.
      // TODO: Should this be a MOV instead?
      assert(Op->getValueType(0) == MVT::i32);
      int FI = cast<FrameIndexSDNode>(Op)->getIndex();
      SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i32);
      if (Op->hasOneUse()) {
        return CurDAG->SelectNodeTo(Op, ARC::ADDrli, MVT::i32, TFI,
            CurDAG->getTargetConstant(0, MVT::i32));
      }
      return CurDAG->getMachineNode(ARC::ADDrli, dl, MVT::i32, TFI,
          CurDAG->getTargetConstant(0, MVT::i32));
    }
    default:
      // Do nothing - let SelectCode handle it.
      break;
  }

  // SelectCode is generated by tablegen.
  return SelectCode(Op);
}

/// Converts a legalized DAG into an ARCOMPACT-specific DAG, ready for
/// instruction scheduling.
FunctionPass *llvm::createARCompactISelDag(ARCompactTargetMachine &TM) {
  return new ARCompactDAGToDAGISel(TM);
}
